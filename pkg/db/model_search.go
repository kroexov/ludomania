// Code generated by mfd-generator v0.4.5; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"time"

	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type LudomanSearch struct {
	search

	ID                   *int
	LudomanNickname      *string
	TgID                 *int
	Balance              *int
	Losses               *int
	TotalLost            *int
	TotalWon             *int
	AdsWatched           *int
	Coefficient          *int
	IDs                  []int
	LudomanNicknameILike *string
}

func (ls *LudomanSearch) Apply(query *orm.Query) *orm.Query {
	if ls == nil {
		return query
	}
	if ls.ID != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.ID, ls.ID)
	}
	if ls.LudomanNickname != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.LudomanNickname, ls.LudomanNickname)
	}
	if ls.TgID != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.TgID, ls.TgID)
	}
	if ls.Balance != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.Balance, ls.Balance)
	}
	if ls.Losses != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.Losses, ls.Losses)
	}
	if ls.TotalLost != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.TotalLost, ls.TotalLost)
	}
	if ls.TotalWon != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.TotalWon, ls.TotalWon)
	}
	if ls.AdsWatched != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.AdsWatched, ls.AdsWatched)
	}
	if ls.Coefficient != nil {
		ls.where(query, Tables.Ludoman.Alias, Columns.Ludoman.Coefficient, ls.Coefficient)
	}
	if len(ls.IDs) > 0 {
		Filter{Columns.Ludoman.ID, ls.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ls.LudomanNicknameILike != nil {
		Filter{Columns.Ludoman.LudomanNickname, *ls.LudomanNicknameILike, SearchTypeILike, false}.Apply(query)
	}

	ls.apply(query)

	return query
}

func (ls *LudomanSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ls == nil {
			return query, nil
		}
		return ls.Apply(query), nil
	}
}

type TransactionSearch struct {
	search

	ID            *int
	FromLudomanID *int
	ToLudomanID   *int
	Amount        *int
	CreatedAt     *time.Time
	IDs           []int
}

func (ts *TransactionSearch) Apply(query *orm.Query) *orm.Query {
	if ts == nil {
		return query
	}
	if ts.ID != nil {
		ts.where(query, Tables.Transaction.Alias, Columns.Transaction.ID, ts.ID)
	}
	if ts.FromLudomanID != nil {
		ts.where(query, Tables.Transaction.Alias, Columns.Transaction.FromLudomanID, ts.FromLudomanID)
	}
	if ts.ToLudomanID != nil {
		ts.where(query, Tables.Transaction.Alias, Columns.Transaction.ToLudomanID, ts.ToLudomanID)
	}
	if ts.Amount != nil {
		ts.where(query, Tables.Transaction.Alias, Columns.Transaction.Amount, ts.Amount)
	}
	if ts.CreatedAt != nil {
		ts.where(query, Tables.Transaction.Alias, Columns.Transaction.CreatedAt, ts.CreatedAt)
	}
	if len(ts.IDs) > 0 {
		Filter{Columns.Transaction.ID, ts.IDs, SearchTypeArray, false}.Apply(query)
	}

	ts.apply(query)

	return query
}

func (ts *TransactionSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ts == nil {
			return query, nil
		}
		return ts.Apply(query), nil
	}
}
